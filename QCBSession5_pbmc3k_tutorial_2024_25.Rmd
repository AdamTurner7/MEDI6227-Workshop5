---
title: "QCB 2024/25 Session 5: Seurat - Guided Clustering Tutorial"
output:
  html_document:
    theme: flatly
    df_print: kable
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
editor_options: 
  markdown: 
    wrap: 72
---

------------------------------------------------------------------------

```{r setup, include=FALSE}
all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE
)
```

# Tutorial background and dataset information.

This scRNA-seq tutorial is adapted from the Seurat introductory training
vignette (Guided tutorial of 2,700 PBMCs:
<https://satijalab.org/seurat/articles/pbmc3k_tutorial.html>).

For this tutorial, we will be analyzing the a dataset of Peripheral
Blood Mononuclear Cells (PBMC) freely available from 10X Genomics. There
are 2,700 single cells that were sequenced on the Illumina NextSeq 500.
The raw data from 10x Genomics can be found
[here](https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz).

**QCB READ ME:** Please register and log in and try to download the data
to your workshop PC. We have also placed a copy of this data on the
blackboard module page (Here:
<https://blackboard.soton.ac.uk/webapps/blackboard/content/listContentEditable.jsp?content_id=_5875013_1&course_id=_213518_1>)
for you to download to your workshop PC.

**QCB READ ME:** We would recommend that you spend some time evaluating
the wealth of freely available data sets generated by 10x Genomics.

**QCB READ ME:** What are PBMCs? - If you are not familiar with these
laboratory cell suspensions then please take some time to read the
following online resource at the NIH HCBI library:
<https://www.ncbi.nlm.nih.gov/books/NBK500157/>

```{r}
```

**QCB workshop Question 1** - In excel list the expected cell types
found in a PBMC suspension, their proportions, and their canonical
markers (either protein-based or at the level of gene expression (i.e.
lineage specific transcripts)). You many need to search other resources
online (e.g. Cellmarker database:
<https://academic.oup.com/nar/article/47/D1/D721/5115823>)

{r}

# Setup the Seurat Object

We start by setting up your R session, loading libraries and reading in
the data.

The `Read10X()` function reads in the output of the
[cellranger](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger)
pipeline from 10X, returning a unique molecular identified (UMI) count
matrix. The values in this matrix represent the number of molecules for
each feature (i.e. gene; row) that are detected in each cell (column).

We next use the count matrix to create a `Seurat` object. The object
serves as a container that contains both data (like the count matrix)
and analysis (like PCA, or clustering results) for a single-cell
dataset. For a technical discussion of the `Seurat` object structure,
check out our [GitHub Wiki](https://github.com/satijalab/seurat/wiki).
For example, the count matrix is stored in `pbmc[["RNA"]]@counts`.

```{r}
#install scater as it has some nice functions to visualize and evaluate stages of your analyses in your workshops
#install.packages("remotes")
#remotes::install_github("davismcc/scater")
```

```{r init}
#Load R libraries
library(dplyr)
library(patchwork)
library(Seurat)

# Load the PBMC dataset
pbmc.data <- Read10X(data.dir = "filtered_gene_bc_matrices/hg19/")
# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc
```

**QCB workshop Question 2** - Record the dimension of the dataset in the
Seurat object and determine the number of detected genes and cell
barcodes?

```{r}
#Use this R chunk for recording your answer to QCB workshop question 2
```

**QCB workshop Question 3** - Investigate what the CreateSeuratObject
function options (min.cells = 3 and min.features = 200) does to the data
and state why this is an important step prior to downstream DGE
analytics?

```{r}
#Use this R chunk for recording your answer to QCB workshop question 3
```

**QCB workshop Question 4** - Investigate the structure of the pbmc.data
and describe the slots in the pbmc Seurat object. Complete the
'Location' and 'Description' columns in the table below:

**Slot Location** **Description\
**assays\
meta.data\
active.assay\
active.ident\
graphs\
neighbors\
reductions\
images\
project.name\
misc\
version commands\
tools

```{r}
```

<details>

<summary>**What does data in a count matrix look like?**</summary>

```{r}
# Lets examine a few genes in the first thirty cells
pbmc.data[c("CD3D","TCL1A","MS4A1"), 1:30]
```

The `.` values in the matrix represent 0s (no molecules detected). Since
most values in an scRNA-seq matrix are 0, Seurat uses a sparse-matrix
representation whenever possible. This results in significant memory and
speed savings for Drop-seq/inDrop/10x data.

```{r}
dense.size <- object.size(as.matrix(pbmc.data))
dense.size
sparse.size <- object.size(pbmc.data)
sparse.size
dense.size / sparse.size
```

**QCB workshop Question 5** - Record the approxiate compression ratio of
a sparse versus a dense matrix?

```{r}
#Use this R chunk for recording your answer to QCB workshop question 5
```

</details>

Â  \# Standard pre-processing workflow

The steps below encompass the standard pre-processing workflow for
scRNA-seq data in Seurat. These represent the selection and filtration
of cells based on QC metrics, data normalization and scaling, and the
detection of highly variable features.

## QC and selecting cells for further analysis

Seurat allows you to easily explore QC metrics and filter cells based on
any user-defined criteria. A few QC metrics [commonly
used](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4758103/) by the
community include

-   The number of unique genes detected in each cell.
    -   Low-quality cells or empty droplets will often have very few
        genes
    -   Cell doublets or multiplets may exhibit an aberrantly high gene
        count
-   Similarly, the total number of molecules detected within a cell
    (correlates strongly with unique genes)
-   The percentage of reads that map to the mitochondrial genome
    -   Low-quality / dying cells often exhibit extensive mitochondrial
        contamination
    -   We calculate mitochondrial QC metrics with the
        `PercentageFeatureSet()` function, which calculates the
        percentage of counts originating from a set of features
    -   We use the set of all genes starting with `MT-` as a set of
        mitochondrial genes

\#**QCB READ ME:** All human mitochondrial gene symbols start with the
MT- prefix. the caret symbol is regular expression
(<https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html>)
used by this Seurat function to subset the calculation to be only
performed on the row.names that start with MT-.

```{r mito, fig.height=7, fig.width=13}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-") 
```

<details>

<summary>**Where are QC metrics stored in Seurat?**</summary>

-   The number of unique genes and total molecules are automatically
    calculated during `CreateSeuratObject()`

    -   You can find them stored in the object meta data

    ```{r qc, fig.height=7, fig.width=13}
    # Show QC metrics for the first 5 cells
    head(pbmc@meta.data, 5)
    ```

</details>

In the example below, we visualize QC metrics, and use these to filter
cells: \* We filter cells that have unique feature counts over 2,500 or
less than 200 \* We filter cells that have \>5% mitochondrial counts

```{r qc2, fig.height=7, fig.width=13}
#Visualize QC metrics as a violin plot
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

```{r qc3, fig.height=7, fig.width=13}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
plot1 + plot2
```

```{r qc4, fig.height=7, fig.width=13}
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
```

<details>

<summary>**Explore QC and cell barcode filtering?**</summary>

**QCB workshop Question 6** - Do you agree with the filtering criteria
used above. Please refer to the quality control section of the scRNA-seq
best practices paper (Luecken and Theis - scRNAseq best practices MSB
2019.pdf) available at blackboard for guidance. Compare and contrast
your best practices guided filtering to the filtering suggested in the
tutorial and record any differences that may impact downstream analyses?

**Hint:** create a new Seurat object, so you can compare and contrast
your filtering strategies

pmbc.filtering.1 \<- pmbc

pmbc.filtering.2 \<- pmbc

```{r}
#Use this R chunk for recording your answer to QCB workshop question 6
```

------------------------------------------------------------------------

# Normalizing the data

After removing unwanted cells from the dataset, the next step is to
normalize the data. By default, we employ a global-scaling normalization
method "LogNormalize" that normalizes the feature expression
measurements for each cell by the total expression, multiplies this by a
scale factor (10,000 by default), and log-transforms the result.
Normalized values are stored in `pbmc[["RNA"]]@data`.

```{r normalize}
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 1e4)
```

For clarity, in this previous line of code (and in future commands), we
provide the default values for certain parameters in the function call.
However, this isn't required and the same behavior can be achieved with:

```{r normalize.default, eval = FALSE}
pbmc <- NormalizeData(pbmc)
```

**QCB workshop Question 7** - Navigate to the location of the raw UMI
counts and normalised data in the pbmc Seurat object and record the
location of each below, before saving as an external matrix to the
Seurat object.

```{r}
#Use this R chunk for recording your answer to QCB workshop question 7
```

**QCB workshop Question 8** - Now investigate the effect of global
normalisation by comparing the normalised data to the UMI counts data
using PCA. What do you notice when you run the following comparative
analysis below?

```{r}
#https://cran.r-project.org/bin/macosx/tools/

#export the Seurat to a scater object - 
pbmc.sce <- as.SingleCellExperiment(pbmc,assay = "RNA")
detach(package:Seurat, TRUE)
#remove.packages("irlba")
#install.packages("irlba",type = "source")
#library(irlba)
library(scater)
pbmc.sce <- scater::runPCA(pbmc.sce,exprs_values = "counts")
p1 <- scater::plotPCA(pbmc.sce,size_by = "nCount_RNA",colour_by = "nFeature_RNA")+ ggtitle("PCA for UMI counts")
detach(package:scater, TRUE)


#export the Seurat to a scater object
library(Seurat)
pbmc.sce.2 <- as.SingleCellExperiment(pbmc,assay = "RNA")
detach(package:Seurat, TRUE)
library(scater)
pbmc.sce.2 <- scater::logNormCounts(pbmc.sce.2)
pbmc.sce.2 <- scater::runPCA(pbmc.sce.2,exprs_values = "logcounts")
p2 <- scater::plotPCA(pbmc.sce.2,size_by = "nCount_RNA",colour_by = "nFeature_RNA")+ ggtitle("PCA for normalised data")
detach(package:scater, TRUE)

p1+p2


```

```{r}
#Use this R chunk for recording your answer to QCB workshop question 8
```

# Identification of highly variable features (feature selection)

We next calculate a subset of features that exhibit high cell-to-cell
variation in the dataset (i.e, they are highly expressed in some cells,
and lowly expressed in others). We and
[others](https://www.nature.com/articles/nmeth.2645) have found that
focusing on these genes in downstream analysis helps to highlight
biological signal in single-cell datasets.

Our procedure in Seurat is described in detail
[here](https://doi.org/10.1016/j.cell.2019.05.031), and improves on
previous versions by directly modeling the mean-variance relationship
inherent in single-cell data, and is implemented in the
`FindVariableFeatures()` function. By default, we return 2,000 features
per dataset. These will be used in downstream analysis, like PCA.

**#QCB READ ME:** Download and read both of these articles to understand
how the next function works, highlight any assumptions and limitations
of this approach to feature selection.

```{r var_features, fig.height=5, fig.width=11}
library(Seurat)
pbmc <- FindVariableFeatures(pbmc, selection.method = 'vst', nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```

**QCB workshop Question 9** - What are the top ten variable genes in the
pmbc dataset? Compare and contrast them to your excel list of pmbc
markers (QCB workshop Question 1).

```{r}
#Use this R chunk for recording your answer to QCB workshop question 9
```

**QCB workshop Question 10** - Where are the variable genes stored in
the pmbc Seurat object and how do you view them? Print out the
vst.variance.standardized value for each of the 2000 variable genes in
descending order

```{r}
#Use this R chunk for recording your answer to QCB workshop question 10

#This is the answer:
genes.vst <- as.data.frame(cbind(rownames(pbmc),pbmc@assays$RNA@meta.data$vf_vst_counts_variance.standardized))
colnames(genes.vst) <-c("gene","vst")
var.genes <- VariableFeatures(pbmc)
genes.vst.variable <- genes.vst[genes.vst$gene %in% var.genes,]
genes.vst.variable <- genes.vst.variable[order(genes.vst.variable$vst,decreasing = T ),] 
```

# Identification of Highly Expressed Genes (feature exploration)

```{r}
#Be patient these plots can be slow to load.
detach(package:Seurat, TRUE)
library(scater)
plot4 <- plotHighestExprs(pbmc.sce.2,exprs_values = "counts",colour_cells_by = "nFeature_RNA")
plot4
```

```{r}
#Be patient these plots can be slow to load.
plot5 <- plotHighestExprs(pbmc.sce.2,exprs_values = "counts",colour_cells_by = "nCount_RNA")
plot5
```

```{r}
#Be patient these plots can be slow to load.
plot6<- plotHighestExprs(pbmc.sce.2,exprs_values = "counts",colour_cells_by = "percent.mt")
plot6

```

# Exploration of Variable Genes for feature selection

```{r}
#Extract the variable genes to plot
detach(package:scater, TRUE)
library(Seurat)
pmbc.variable.genes <- pbmc[c(VariableFeatures(pbmc)),]
pmbc.variable.genes.sce <- as.SingleCellExperiment(pmbc.variable.genes,assay = "RNA")
detach(package:Seurat, TRUE)
library(scater)
#Be patient these plots can be slow to load.
plot7 <- plotHighestExprs(pmbc.variable.genes.sce,exprs_values = "counts",colour_cells_by = "nFeature_RNA")
plot7
```

```{r}
#Be patient these plots can be slow to load.
plot8 <- plotHighestExprs(pmbc.variable.genes.sce,exprs_values = "counts",colour_cells_by = "nCount_RNA")
plot8
```

```{r}
#Be patient these plots can be slow to load.
plot9 <- plotHighestExprs(pmbc.variable.genes.sce,exprs_values = "counts",colour_cells_by = "percent.mt")
plot9
detach(package:scater, TRUE)
```

**QCB workshop Question 11** - Use the last three R code chunks (Answer
to question 10, Identification of Highly Expressed Genes, Identification
of Variable Genes ) to understand the differences between highly
expressed and highly variable genes. Record your observations below?
What type of genes are over-represented in the highly expressed genes?
What type of genes are over-represented in the highly variable genes
(hint:See Question 1)?

```{r}
#Use this R chunk for recording your answer to QCB workshop question 11
```

------------------------------------------------------------------------

# Scaling the data

Next, we apply a linear transformation ('scaling') that is a standard
pre-processing step prior to dimensional reduction techniques like PCA.
The `ScaleData()` function:

-   Shifts the expression of each gene, so that the mean expression
    across cells is 0
-   Scales the expression of each gene, so that the variance across
    cells is 1
    -   This step gives equal weight in downstream analyses, so that
        highly-expressed genes do not dominate
-   The results of this are stored in `pbmc[["RNA"]]@scale.data`

**QCB READ ME:** After reading the Feature selection, dimensionality
reduction and visualisation of the Luecken et al., Current best
practices in scRNA-seq analysis: a tutorial, think about the appropriate
use of measured and corrected data for different downstream analyses?

```{r regress, fig.height=7, fig.width=11, results='hide'}
library(Seurat)
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
```

<details>

<summary>**This step takes too long! Can I make it faster?**</summary>

Scaling is an essential step in the Seurat workflow, but only on genes
that will be used as input to PCA. Therefore, the default in
`ScaleData()` is only to perform scaling on the previously identified
variable features (2,000 by default). To do this, omit the `features`
argument in the previous function call, i.e.

```{r regressvar, fig.height=7, fig.width=11, results='hide',eval = FALSE}
pbmc <- ScaleData(pbmc)
```

Your PCA and clustering results will be unaffected. However, Seurat
heatmaps (produced as shown below with `DoHeatmap()`) require genes in
the heatmap to be scaled, to make sure highly-expressed genes don't
dominate the heatmap. To make sure we don't leave any genes out of the
heatmap later, we are scaling all genes in this tutorial.

</details>

Â 

<details>

<summary>**How can I remove unwanted sources of variation, as in Seurat
v2?**</summary>

In `Seurat v2` we also use the `ScaleData()` function to remove unwanted
sources of variation from a single-cell dataset. For example, we could
'regress out' heterogeneity associated with (for example) cell cycle
stage, or mitochondrial contamination. These features are still
supported in `ScaleData()` in `Seurat v3`, i.e.:

```{r regressvarmt, fig.height=7, fig.width=11, results='hide',eval = FALSE}
pbmc <- ScaleData(pbmc, vars.to.regress = 'percent.mt')
```

**QCB workshop Question 12** - Based on your data exploration today,
what other confounding variables may you like to consider for
regression?

```{r}
#Use this R chunk for recording your answer to QCB workshop question 12
```

# Optional Seurat functionality to explore if you have time. Make sure you read and understand the paper before using.

However, particularly for advanced users who would like to use this
functionality, we strongly recommend the use of our new normalization
workflow, `SCTransform()`. The method is described in our
[paper](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1),
with a separate vignette using Seurat v3
[here](sctransform_vignette.html). As with `ScaleData()`, the function
`SCTransform()` also includes a `vars.to.regress` parameter.

```{r}
#Save rds file of your work today
saveRDS(pbmc, file = "pbmc3k_QCBSession5.rds")

#Then save a copy of your .rmd file
```

######################## 

##END OF QCB SESSION 5 \## Well done you survived it! \##

<details>

<summary>**Session Info**</summary>

```{r}
sessionInfo()
```

</details>
